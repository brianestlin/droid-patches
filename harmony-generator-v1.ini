# INPUTS:
#  I1: [mel cv] melody cv in
#  I4: [adv] advance chord sequencer
#  I5: [root] root in, v/oct
#  I6: [chord] select from 10 chord types
#  I8: [reset] reset chord sequencer

# OUTPUTS:
#  O1: [mel] melody 1v/oct output
#  O2: [har 1] first harmony 1v/oct output
#  O3: [har 2] second harmony 1v/oct output
#  O4: [har 3] third harmony 1v/oct output
#  O5: [root] root of underlying chord
#  O6: [third] third of underlying chord
#  O7: [fifth] fifth of underlying chord
#  O8: [seventh] seventh of underlying chord

# CONTROLLER 1:
#  B1.1: [adv]
#  B1.2: [reset]
#  B1.3: [root] pots control roots
#  B1.4: [chord] pots control degree

[p2b8]

# -------------------------------------------------
# Underlying Chord
# -------------------------------------------------

[chord]
    pitch = 0
    spread = 0
    inversion = 1
    root = _PSEQ
    degree = _DEGREESEQ
    select1 = 1
    select3 = 1
    select5 = 1
    select7 = 1
    select9 = 0
    select11 = 0
    select13 = 0
    output1 = _ROOT_V
    output2 = _THIRD_V
    output3 = _FIFTH_V
    output4 = _SEVENTH_V

[math]
    input1 = _ROOT_V * 120
    input2 = 12
    modulo = _ROOT_PITCH

[math]
    input1 = _THIRD_V * 120
    input2 = 12
    modulo = _THIRD_PITCH

[math]
    input1 = _FIFTH_V * 120
    input2 = 12
    modulo = _FIFTH_PITCH

[math]
    input1 = _SEVENTH_V * 120
    input2 = 12
    modulo = _SEVENTH_PITCH

[math]
    input1 = _ROOT_V * 120
    input2 = _THIRD_V * 120
    difference = _THIRD_MINUS_ROOT

[math]
    input1 = _THIRD_V * 120
    input2 = _FIFTH_V * 120
    difference = _FIFTH_MINUS_THIRD

[math]
    input1 = _FIFTH_V * 120
    input2 = _SEVENTH_V * 120
    difference = _SEVENTH_MINUS_FIFTH

[math]
    input1 = _SEVENTH_V * 120
    input2 = _ROOT_V * 120 + 12
    difference = _ROOT_MINUS_SEVENTH

[copy]
    input = _ROOT_V
    output = O5

[copy]
    input = _THIRD_V
    output = O6

[copy]
    input = _FIFTH_V
    output = O7

[copy]
    input = _SEVENTH_V
    output = O8

# -------------------------------------------------
# Input
# -------------------------------------------------

# Quantize the melody CV input to semitones.
[quantizer]
    input = I1
    steps = 12
    bypass = 0
    output = _QUANTIZED_INPUT

# Determine the "pitch class" (C, C#, D, etc) of the melody input.
[math]
    input1 = _QUANTIZED_INPUT * 120
    input2 = 12
    modulo = _INPUT_PITCH

# Determine the "pitch class" of the root input.
[math]
    input1 = I5 * 120
    input2 = 12
    modulo = _PSEQ

# Make sure chord input is non-negative.
[math]
    input1 = I6
    input2 = 0
    maximum = _CHORDINPUT

# The chord input will select discretely one of 10 chord types (translated to Droid "degrees" by the switch below).
[math]
    input1 = _CHORDINPUT * 10
    floor = _CHORDTYPE

# The selectable chord types / degrees are:
# 0. dim7 / whole-half diminished (10)
# 1. min7b5 / locrian (23)
# 2. min7 / dorian (6)
# 3. sus7b9 / mixolydian sus4 b9 (16)
# 4. sus7 / mixolydian sus4 (3)
# 5. 7b9 / mixolydian b9 (18)
# 6. 7 / mixolydian (12)
# 7. maj7 / lydian (0)
# 8. altered / altered (4)
# 9. maj7#5 / maj7#5 (22)
[switch]
    input1 = 10
    input2 = 23
    input3 = 6
    input4 = 16
    input5 = 3
    input6 = 18
    input7 = 12
    input8 = 0
    input9 = 4
    input10 = 22
    offset = _CHORDTYPE
    output1 = _DEGREESEQ

# -------------------------------------------------
# Matching Index
# The "compare" circuits in this section are used to figure out which chord tone matches the input melody pitch, if any. A corresponding index is then fed to a switch in the Output Harmony section.  "Compare" circuits are used instead of "multicompare" because I needed the "precision" parameter.
# -------------------------------------------------

[compare]
    input = _INPUT_PITCH
    compare = _ROOT_PITCH
    ifequal = 0
    else = _COMPARE_357
    output = _MATCHING_INDEX
    precision = 0.002

[compare]
    input = _INPUT_PITCH
    compare = _THIRD_PITCH
    ifequal = 3
    else = _COMPARE_57
    output = _COMPARE_357
    precision = 0.002

[compare]
    input = _INPUT_PITCH
    compare = _FIFTH_PITCH
    ifequal = 2
    else = _COMPARE_7
    output = _COMPARE_57
    precision = 0.002

[compare]
    input = _INPUT_PITCH
    compare = _SEVENTH_PITCH
    ifequal = 1
    else = -1
    output = _COMPARE_7
    precision = 0.002

# -------------------------------------------------
# Alternative Harmony: Diminished
# -------------------------------------------------

[copy]
    input = -3
    output = _ALTERNATIVE_FIRST_DELTA

[copy]
    input = -3
    output = _ALTERNATIVE_SECOND_DELTA

[copy]
    input = -3
    output = _ALTERNATIVE_THIRD_DELTA

# -------------------------------------------------
# Output Harmony
# -------------------------------------------------

# This switch determines *in which order* to subtract "deltas" (in semitones) in order to derive the correct chord inversion from the melody note.  I.e. if the melody note is the root, then to get the first harmony note you'd subtract the "root minus seventh" delta, but if the melody note is the third then to get the first harmony note you'd subtract "third minus root".
[switch]
    input1 = _ROOT_MINUS_SEVENTH
    input2 = _SEVENTH_MINUS_FIFTH
    input3 = _FIFTH_MINUS_THIRD
    input4 = _THIRD_MINUS_ROOT
    offset = _MATCHING_INDEX
    output1 = _CHORDTONE_FIRST_DELTA
    output2 = _CHORDTONE_SECOND_DELTA
    output3 = _CHORDTONE_THIRD_DELTA

# If the input note matched any chord note, use chordtone harmony, otherwise use alternative harmony.
[compare]
    input = _MATCHING_INDEX
    compare = -1
    ifequal = _ALTERNATIVE_FIRST_DELTA
    else = _CHORDTONE_FIRST_DELTA
    output = _FIRST_DELTA

# If the input note matched any chord note, use chordtone harmony, otherwise use alternative harmony.
[compare]
    input = _MATCHING_INDEX
    compare = -1
    ifequal = _ALTERNATIVE_SECOND_DELTA
    else = _CHORDTONE_SECOND_DELTA
    output = _SECOND_DELTA

# If the input note matched any chord note, use chordtone harmony, otherwise use alternative harmony.
[compare]
    input = _MATCHING_INDEX
    compare = -1
    ifequal = _ALTERNATIVE_THIRD_DELTA
    else = _CHORDTONE_THIRD_DELTA
    output = _THIRD_DELTA

[copy]
    input = _QUANTIZED_INPUT * 120
    output = _OUTPITCH1

[copy]
    input = _OUTPITCH1 + _FIRST_DELTA
    output = _OUTPITCH2

[copy]
    input = _OUTPITCH2 + _SECOND_DELTA
    output = _OUTPITCH3

[copy]
    input = _OUTPITCH3 + _THIRD_DELTA
    output = _OUTPITCH4

[copy]
    input = _OUTPITCH1 / 120
    output = O1

[copy]
    input = _OUTPITCH2 / 120
    output = O2

[copy]
    input = _OUTPITCH3 / 120
    output = O3

[copy]
    input = _OUTPITCH4 / 120
    output = O4

# -------------------------------------------------
# TODO
# TODO:
# - Implement other alternative harmonies
# - Implement drop 2 and drop 2/4 voicings
# - Show stage with LEDs (don't think the circuit supports this)
# - Instead of "adv" and "reset", consider just going direct to each stage with a button press (note, the circuit doesn't seem to support this)
# - Implement version that outputs EnsOsc "scale" control
# -------------------------------------------------

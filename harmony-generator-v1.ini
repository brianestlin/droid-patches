# INPUTS:
#  I1: [mel cv] melody cv in
#  I5: [root] root in, v/oct
#  I6: [chord] select from 10 chord types

# OUTPUTS:
#  O1: [mel] melody 1v/oct output
#  O2: [har 1] first harmony 1v/oct output
#  O3: [har 2] second harmony 1v/oct output
#  O4: [har 3] third harmony 1v/oct output
#  O5: [root] root of underlying chord
#  O6: [third] third of underlying chord
#  O7: [fifth] fifth of underlying chord
#  O8: [seventh] seventh of underlying chord

# CONTROLLER 1:
#  B1.1: [dim]
#  B1.2: [rand]
#  B1.3: [dimmaj]
#  B1.4: [randlock]
#  B1.5: [para pass] parallel passing
#  B1.6: [fuzzy]
#  B1.7: [fixed para] melody note always = root, chord type is constant
#  B1.8: [unison] all outputs play melody note

[p2b8]

# -------------------------------------------------
# Input
# -------------------------------------------------

# Quantize the melody CV input to semitones.
[quantizer]
    input = I1
    steps = 12
    bypass = 0
    output = _QUANTIZED_MEL_INPUT
    changed = _NOTECHANGE

# Convert the melody input to an integer note value.
[math]
    input1 = _QUANTIZED_MEL_INPUT * 120
    round = _MEL_INPUT_MIDI

# Determine the "pitch class" (C, C#, D, etc) of the melody input.
[math]
    input1 = _MEL_INPUT_MIDI
    input2 = 12
    modulo = _MEL_INPUT_PITCH

# Determine the "pitch class" of the root input.
[math]
    input1 = I5 * 120
    input2 = 12
    modulo = _ROOT_INPUT_PITCH

# Make sure chord input is non-negative.
[math]
    input1 = I6
    input2 = 0
    maximum = _CHORDINPUT

# The chord input will select discretely one of 10 chord types (translated to Droid "degrees" by the switch below).
[math]
    input1 = _CHORDINPUT * 20
    floor = _CHORDTYPE

# This buttongroup selects the harmony algorithm. The harmony algorithm determines how non-chord-tones are harmonized. 
# - "Dim" constructs a fully-diminished chord down from the melody note. 
# - "Rand" constructs a new random chord with each gate. 
# - "DimMaj7" constructs a diminished maj7 chord with the melody note as the maj7.  
# - "Para" (for "parallel" constructs a chord using the same intervals as were used to harmonize the most recent chord-tone.
[buttongroup]
    button1 = B1.1
    button2 = B1.2
    button3 = B1.3
    button4 = B1.4
    button5 = B1.5
    button6 = B1.6
    button7 = B1.7
    button8 = B1.8
    led1 = L1.1
    led2 = L1.2
    led3 = L1.3
    led4 = L1.4
    led5 = L1.5
    led6 = L1.6
    led7 = L1.7
    led8 = L1.8
    output = _HARMONIZER

# The selectable chord types / degrees are:
# 0. dim7 / whole-half diminished (10)
# 1. min7b5 / locrian (23)
# 2. min7 / dorian (6)
# 3. sus7b9 / mixolydian sus4 b9 (16)
# 4. sus7 / mixolydian sus4 (3)
# 5. 7b9 / mixolydian b9 (18)
# 6. 7 / mixolydian (12)
# 7. maj7 / lydian (0)
# 8. altered / altered (4)
# 9. maj7#5 / maj7#5 (22)
[switch]
    input1 = 10
    input2 = 23
    input3 = 6
    input4 = 16
    input5 = 3
    input6 = 18
    input7 = 12
    input8 = 0
    input9 = 4
    input10 = 22
    offset = _CHORDTYPE
    output1 = _DEGREESEQ

# This circuit lets the "fixed para" harmonizer override the root input with the melody note. (In "fixed para" mode, the melody note determines the chord root.)
[compare]
    input = _HARMONIZER
    compare = 6
    ifequal = _MEL_INPUT_PITCH
    else = _ROOT_INPUT_PITCH
    output = _ROOTSEQ

# -------------------------------------------------
# Underlying Chord
# -------------------------------------------------

# Based on the root input and chordtype input, this circuit determines the root, third, fifth, and seventh of the underlying chord. These are used for establishing pitch classes (below), so inversion/spread/pitch are held constant.
[chord]
    pitch = 0
    spread = 0
    inversion = 1
    root = _ROOTSEQ
    degree = _DEGREESEQ
    select1 = 1
    select3 = 1
    select5 = 1
    select7 = 1
    select9 = 0
    select11 = 0
    select13 = 0
    output1 = _ROOT_V
    output2 = _THIRD_V
    output3 = _FIFTH_V
    output4 = _SEVENTH_V

# Convert the root voltage to an integer note value.
[math]
    input1 = _ROOT_V * 120
    round = _ROOT_MIDI

# Convert the root voltage to an integer note value.
[math]
    input1 = _THIRD_V * 120
    round = _THIRD_MIDI

# Convert the root voltage to an integer note value.
[math]
    input1 = _FIFTH_V * 120
    round = _FIFTH_MIDI

# Convert the root voltage to an integer note value.
[math]
    input1 = _SEVENTH_V * 120
    round = _SEVENTH_MIDI

[math]
    input1 = _ROOT_MIDI
    input2 = 12
    modulo = _ROOT_PITCH

[math]
    input1 = _THIRD_MIDI
    input2 = 12
    modulo = _THIRD_PITCH

[math]
    input1 = _FIFTH_MIDI
    input2 = 12
    modulo = _FIFTH_PITCH

[math]
    input1 = _SEVENTH_MIDI
    input2 = 12
    modulo = _SEVENTH_PITCH

[math]
    input1 = _ROOT_MIDI
    input2 = _THIRD_MIDI
    difference = _THIRD_MINUS_ROOT

[math]
    input1 = _THIRD_MIDI
    input2 = _FIFTH_MIDI
    difference = _FIFTH_MINUS_THIRD

[math]
    input1 = _FIFTH_MIDI
    input2 = _SEVENTH_MIDI
    difference = _SEVENTH_MINUS_FIFTH

[math]
    input1 = _SEVENTH_MIDI
    input2 = _ROOT_MIDI + 12
    difference = _ROOT_MINUS_SEVENTH

[copy]
    input = _ROOT_V
    output = O5

[copy]
    input = _THIRD_V
    output = O6

[copy]
    input = _FIFTH_V
    output = O7

[copy]
    input = _SEVENTH_V
    output = O8

# -------------------------------------------------
# Matching Index
# The circuits in this section are used to figure out which chord tone matches the input melody pitch, if any. A corresponding index is then fed to a switch in the Output Harmony section.
# -------------------------------------------------

[multicompare]
    input = _MEL_INPUT_PITCH
    compare1 = _ROOT_PITCH
    compare2 = _THIRD_PITCH
    compare3 = _FIFTH_PITCH
    compare4 = _SEVENTH_PITCH
    ifequal1 = 0
    ifequal2 = 3
    ifequal3 = 2
    ifequal4 = 1
    else = -1
    output = _MATCHING_INDEX

# -------------------------------------------------
# Chordtone Harmony
# -------------------------------------------------

[compare]
    input = _MATCHING_INDEX
    compare = -1
    ifequal = 0
    else = 1
    output = _IS_CHORD_TONE

# This switch determines *in which order* to subtract "deltas" (in semitones) in order to derive the correct chord inversion from the melody note.  I.e. if the melody note is the root, then to get the first harmony note you'd subtract the "root minus seventh" delta, but if the melody note is the third then to get the first harmony note you'd subtract "third minus root".
[switch]
    input1 = _ROOT_MINUS_SEVENTH
    input2 = _SEVENTH_MINUS_FIFTH
    input3 = _FIFTH_MINUS_THIRD
    input4 = _THIRD_MINUS_ROOT
    offset = _MATCHING_INDEX
    output1 = _RAW_CT_DELTA1
    output2 = _RAW_CT_DELTA2
    output3 = _RAW_CT_DELTA3

[sample]
    input = _RAW_CT_DELTA1
    gate = _IS_CHORD_TONE
    output = _CHORDTONE_FIRST_DELTA

[sample]
    input = _RAW_CT_DELTA2
    gate = _IS_CHORD_TONE
    output = _CHORDTONE_SECOND_DELTA

[sample]
    input = _RAW_CT_DELTA3
    gate = _IS_CHORD_TONE
    output = _CHORDTONE_THIRD_DELTA

# -------------------------------------------------
# Alternative Harmony
# -------------------------------------------------

[switch]
    input1 = _ALTERNATIVE_FIRST_DELTA_DIM
    input2 = _ALTERNATIVE_FIRST_DELTA_RANDOM
    input3 = _ALTERNATIVE_FIRST_DELTA_DIMMAJ7
    input4 = _ALTERNATIVE_FIRST_DELTA_RANDOM
    input5 = _ALTERNATIVE_FIRST_DELTA_PARALLEL
    input6 = _ALTERNATIVE_FIRST_DELTA_FUZZY
    offset = _HARMONIZER
    output1 = _ALTERNATIVE_FIRST_DELTA

[switch]
    input1 = _ALTERNATIVE_SECOND_DELTA_DIM
    input2 = _ALTERNATIVE_SECOND_DELTA_RANDOM
    input3 = _ALTERNATIVE_SECOND_DELTA_DIMMAJ7
    input4 = _ALTERNATIVE_SECOND_DELTA_RANDOM
    input5 = _ALTERNATIVE_SECOND_DELTA_PARALLEL
    input6 = _ALTERNATIVE_SECOND_DELTA_FUZZY
    offset = _HARMONIZER
    output1 = _ALTERNATIVE_SECOND_DELTA

[switch]
    input1 = _ALTERNATIVE_THIRD_DELTA_DIM
    input2 = _ALTERNATIVE_THIRD_DELTA_RANDOM
    input3 = _ALTERNATIVE_THIRD_DELTA_DIMMAJ7
    input4 = _ALTERNATIVE_THIRD_DELTA_RANDOM
    input5 = _ALTERNATIVE_THIRD_DELTA_PARALLEL
    input6 = _ALTERNATIVE_THIRD_DELTA_FUZZY
    offset = _HARMONIZER
    output1 = _ALTERNATIVE_THIRD_DELTA

# -------------------------------------------------
# Alternative Harmony: Parallel
# -------------------------------------------------

[logic]
    input1 = _NOTECHANGE
    input2 = _IS_CHORD_TONE
    and = _CHORD_TONE_NOTECHANGE

[queue]
    input = _CHORDTONE_FIRST_DELTA
    clock = _CHORD_TONE_NOTECHANGE
    output1 = _ALTERNATIVE_FIRST_DELTA_PARALLEL

[queue]
    input = _CHORDTONE_SECOND_DELTA
    clock = _CHORD_TONE_NOTECHANGE
    output1 = _ALTERNATIVE_SECOND_DELTA_PARALLEL

[queue]
    input = _CHORDTONE_THIRD_DELTA
    clock = _CHORD_TONE_NOTECHANGE
    output1 = _ALTERNATIVE_THIRD_DELTA_PARALLEL

# -------------------------------------------------
# Alternative Harmony: Fuzzy Parallel
# -------------------------------------------------

[random]
    clock = _NOTECHANGE
    minimum = -1
    maximum = 1
    steps = 3
    output = _RANDOMOFFSET1

[random]
    clock = _NOTECHANGE
    minimum = -1
    maximum = 1
    steps = 3
    output = _RANDOMOFFSET2

[random]
    clock = _NOTECHANGE
    minimum = -1
    maximum = 1
    steps = 3
    output = _RANDOMOFFSET3

[copy]
    input = _ALTERNATIVE_FIRST_DELTA_PARALLEL + _RANDOMOFFSET1
    output = _ALTERNATIVE_FIRST_DELTA_FUZZY

[copy]
    input = _ALTERNATIVE_SECOND_DELTA_PARALLEL + _RANDOMOFFSET2
    output = _ALTERNATIVE_SECOND_DELTA_FUZZY

[copy]
    input = _ALTERNATIVE_THIRD_DELTA_PARALLEL + _RANDOMOFFSET3
    output = _ALTERNATIVE_THIRD_DELTA_FUZZY

# -------------------------------------------------
# Alternative Harmony: Random
# -------------------------------------------------

[multicompare]
    input = _HARMONIZER
    compare1 = 1
    compare2 = 3
    ifequal1 = _NOTECHANGE
    ifequal2 = B1.4
    else = 1
    output = _RANDOMCLOCK

[random]
    clock = _RANDOMCLOCK
    minimum = 2
    maximum = 5
    steps = 4
    output = _RAND_3RD

[compare]
    input = _RAND_3RD
    compare = 5
    ifequal = 7
    else = 6
    output = _RAND_MIN_5TH

[compare]
    input = _RAND_3RD
    compare = 5
    ifequal = 2
    else = 3
    output = _RAND_STEPS_5TH

[random]
    clock = _RANDOMCLOCK
    minimum = _RAND_MIN_5TH
    maximum = 8
    steps = _RAND_STEPS_5TH
    output = _RAND_5TH

[compare]
    input = _RAND_5TH
    compare = 8
    ifequal = 10
    else = 9
    output = _RAND_MIN_7TH

[compare]
    input = _RAND_5TH
    compare = 8
    ifequal = 2
    else = 3
    output = _RAND_STEPS_7TH

[random]
    clock = _RANDOMCLOCK
    minimum = _RAND_MIN_7TH
    maximum = 11
    steps = _RAND_STEPS_7TH
    output = _RAND_7TH

[math]
    input1 = 0
    input2 = _RAND_3RD
    difference = _RAND_THIRD_MINUS_ROOT

[math]
    input1 = _RAND_3RD
    input2 = _RAND_5TH
    difference = _RAND_FIFTH_MINUS_THIRD

[math]
    input1 = _RAND_5TH
    input2 = _RAND_7TH
    difference = _RAND_SEVENTH_MINUS_FIFTH

[math]
    input1 = _RAND_7TH
    input2 = 12
    difference = _RAND_ROOT_MINUS_SEVENTH

# This switch determines *in which order* to subtract "deltas" (in semitones) in order to derive the correct chord inversion from the melody note.  I.e. if the melody note is the root, then to get the first harmony note you'd subtract the "root minus seventh" delta, but if the melody note is the third then to get the first harmony note you'd subtract "third minus root".
[switch]
    input1 = _RAND_ROOT_MINUS_SEVENTH
    input2 = _RAND_SEVENTH_MINUS_FIFTH
    input3 = _RAND_FIFTH_MINUS_THIRD
    input4 = _RAND_THIRD_MINUS_ROOT
    offset = _RAND_OFFSET
    output1 = _ALTERNATIVE_FIRST_DELTA_RANDOM
    output2 = _ALTERNATIVE_SECOND_DELTA_RANDOM
    output3 = _ALTERNATIVE_THIRD_DELTA_RANDOM

[random]
    clock = _RANDOMCLOCK
    minimum = 0
    maximum = 3
    steps = 4
    output = _RAND_OFFSET

# -------------------------------------------------
# Alternative Harmony: Diminished
# -------------------------------------------------

[copy]
    input = -3
    output = _ALTERNATIVE_FIRST_DELTA_DIM

[copy]
    input = -3
    output = _ALTERNATIVE_SECOND_DELTA_DIM

[copy]
    input = -3
    output = _ALTERNATIVE_THIRD_DELTA_DIM

# -------------------------------------------------
# Alternative Harmony: Diminished Maj7
# -------------------------------------------------

[copy]
    input = -5
    output = _ALTERNATIVE_FIRST_DELTA_DIMMAJ7

[copy]
    input = -3
    output = _ALTERNATIVE_SECOND_DELTA_DIMMAJ7

[copy]
    input = -3
    output = _ALTERNATIVE_THIRD_DELTA_DIMMAJ7

# -------------------------------------------------
# Output Harmony
# -------------------------------------------------

# If the input note matched any chord note, use chordtone harmony, otherwise use alternative harmony.
[compare]
    input = _MATCHING_INDEX
    compare = -1
    ifequal = _ALTERNATIVE_FIRST_DELTA
    else = _CHORDTONE_FIRST_DELTA
    output = _FIRST_DELTA

# If the input note matched any chord note, use chordtone harmony, otherwise use alternative harmony.
[compare]
    input = _MATCHING_INDEX
    compare = -1
    ifequal = _ALTERNATIVE_SECOND_DELTA
    else = _CHORDTONE_SECOND_DELTA
    output = _SECOND_DELTA

# If the input note matched any chord note, use chordtone harmony, otherwise use alternative harmony.
[compare]
    input = _MATCHING_INDEX
    compare = -1
    ifequal = _ALTERNATIVE_THIRD_DELTA
    else = _CHORDTONE_THIRD_DELTA
    output = _THIRD_DELTA

# If harmonizer is "unison", all deltas are always zero.
[compare]
    input = _HARMONIZER
    compare = 7
    ifequal = 0
    else = _FIRST_DELTA
    output = _FIRST_DELTA_OR_UNISON

# If harmonizer is "unison", all deltas are always zero.
[compare]
    input = _HARMONIZER
    compare = 7
    ifequal = 0
    else = _SECOND_DELTA
    output = _SECOND_DELTA_OR_UNISON

# If harmonizer is "unison", all deltas are always zero.
[compare]
    input = _HARMONIZER
    compare = 7
    ifequal = 0
    else = _THIRD_DELTA
    output = _THIRD_DELTA_OR_UNISON

[copy]
    input = _QUANTIZED_MEL_INPUT * 120
    output = _OUTPITCH1

[copy]
    input = _OUTPITCH1 + _FIRST_DELTA_OR_UNISON
    output = _OUTPITCH2

[copy]
    input = _OUTPITCH2 + _SECOND_DELTA_OR_UNISON
    output = _OUTPITCH3

[copy]
    input = _OUTPITCH3 + _THIRD_DELTA_OR_UNISON
    output = _OUTPITCH4

[copy]
    input = _OUTPITCH1 / 120
    output = O1

[copy]
    input = _OUTPITCH2 / 120
    output = O2

[copy]
    input = _OUTPITCH3 / 120
    output = O3

[copy]
    input = _OUTPITCH4 / 120
    output = O4

# -------------------------------------------------
# TODO
# TODO:
# - Implement drop 2 and drop 2/4 voicings
# - Consider a diatonic harmonizer
# - Consider other alternative fixed chords: -3, -2, -4; -2, -2, -5; possibly -3, -2, -3
# - Consider using "fixed-para" for non-chord-tones (i.e. based on root instead of based on last chordtone played) as an alternative "para pass" mode.
# - Consider allowing inversion selection for "fixed para" -- i.e., melody note could be the 7th, 5th, or 3rd instead of the root.
# -------------------------------------------------

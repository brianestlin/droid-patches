# INPUTS:
#  I1: [mel cv] melody cv in
#  I5: [root] root in, v/oct
#  I6: [chord] select from 10 chord types

# OUTPUTS:
#  O1: [mel] melody 1v/oct output
#  O2: [har 1] first harmony 1v/oct output
#  O3: [har 2] second harmony 1v/oct output
#  O4: [har 3] third harmony 1v/oct output
#  O5: [root] root of underlying chord
#  O6: [third] third of underlying chord
#  O7: [fifth] fifth of underlying chord
#  O8: [seventh] seventh of underlying chord

# CONTROLLER 1:
#  B1.1: [dim]
#  B1.2: [rand]
#  B1.3: [dimmaj]
#  B1.4: [randlock]
#  B1.5: [parallel]

[p2b8]

# -------------------------------------------------
# Underlying Chord
# -------------------------------------------------

[chord]
    pitch = 0
    spread = 0
    inversion = 1
    root = _PSEQ
    degree = _DEGREESEQ
    select1 = 1
    select3 = 1
    select5 = 1
    select7 = 1
    select9 = 0
    select11 = 0
    select13 = 0
    output1 = _ROOT_V
    output2 = _THIRD_V
    output3 = _FIFTH_V
    output4 = _SEVENTH_V

[math]
    input1 = _ROOT_V * 120
    input2 = 12
    modulo = _ROOT_PITCH

[math]
    input1 = _THIRD_V * 120
    input2 = 12
    modulo = _THIRD_PITCH

[math]
    input1 = _FIFTH_V * 120
    input2 = 12
    modulo = _FIFTH_PITCH

[math]
    input1 = _SEVENTH_V * 120
    input2 = 12
    modulo = _SEVENTH_PITCH

[math]
    input1 = _ROOT_V * 120
    input2 = _THIRD_V * 120
    difference = _THIRD_MINUS_ROOT

[math]
    input1 = _THIRD_V * 120
    input2 = _FIFTH_V * 120
    difference = _FIFTH_MINUS_THIRD

[math]
    input1 = _FIFTH_V * 120
    input2 = _SEVENTH_V * 120
    difference = _SEVENTH_MINUS_FIFTH

[math]
    input1 = _SEVENTH_V * 120
    input2 = _ROOT_V * 120 + 12
    difference = _ROOT_MINUS_SEVENTH

[copy]
    input = _ROOT_V
    output = O5

[copy]
    input = _THIRD_V
    output = O6

[copy]
    input = _FIFTH_V
    output = O7

[copy]
    input = _SEVENTH_V
    output = O8

# -------------------------------------------------
# Input
# -------------------------------------------------

# Quantize the melody CV input to semitones.
[quantizer]
    input = I1
    steps = 12
    bypass = 0
    output = _QUANTIZED_INPUT
    changed = _NOTECHANGE

# Determine the "pitch class" (C, C#, D, etc) of the melody input.
[math]
    input1 = _QUANTIZED_INPUT * 120
    input2 = 12
    modulo = _INPUT_PITCH

# Determine the "pitch class" of the root input.
[math]
    input1 = I5 * 120
    input2 = 12
    modulo = _PSEQ

# Make sure chord input is non-negative.
[math]
    input1 = I6
    input2 = 0
    maximum = _CHORDINPUT

# The chord input will select discretely one of 10 chord types (translated to Droid "degrees" by the switch below).
[math]
    input1 = _CHORDINPUT * 20
    floor = _CHORDTYPE

# This buttongroup selects the harmony algorithm. The harmony algorithm determines how non-chord-tones are harmonized. 
# - "Dim" constructs a fully-diminished chord down from the melody note. 
# - "Rand" constructs a new random chord with each gate. 
# - "DimMaj7" constructs a diminished maj7 chord with the melody note as the maj7.  
# - "Para" (for "parallel" constructs a chord using the same intervals as were used to harmonize the most recent chord-tone.
[buttongroup]
    button1 = B1.1
    button2 = B1.2
    button3 = B1.3
    button4 = B1.4
    button5 = B1.5
    value1 = 0
    value2 = 1
    value3 = 2
    value4 = 3
    value5 = 4
    led1 = L1.1
    led2 = L1.2
    led3 = L1.3
    led4 = L1.4
    led5 = L1.5
    output = _HARMONIZER

# The selectable chord types / degrees are:
# 0. dim7 / whole-half diminished (10)
# 1. min7b5 / locrian (23)
# 2. min7 / dorian (6)
# 3. sus7b9 / mixolydian sus4 b9 (16)
# 4. sus7 / mixolydian sus4 (3)
# 5. 7b9 / mixolydian b9 (18)
# 6. 7 / mixolydian (12)
# 7. maj7 / lydian (0)
# 8. altered / altered (4)
# 9. maj7#5 / maj7#5 (22)
[switch]
    input1 = 10
    input2 = 23
    input3 = 6
    input4 = 16
    input5 = 3
    input6 = 18
    input7 = 12
    input8 = 0
    input9 = 4
    input10 = 22
    offset = _CHORDTYPE
    output1 = _DEGREESEQ

# -------------------------------------------------
# Matching Index
# The "compare" circuits in this section are used to figure out which chord tone matches the input melody pitch, if any. A corresponding index is then fed to a switch in the Output Harmony section.  "Compare" circuits are used instead of "multicompare" because I needed the "precision" parameter.
# -------------------------------------------------

[compare]
    input = _INPUT_PITCH
    compare = _ROOT_PITCH
    ifequal = 0
    else = _COMPARE_357
    output = _MATCHING_INDEX
    precision = 0.002

[compare]
    input = _INPUT_PITCH
    compare = _THIRD_PITCH
    ifequal = 3
    else = _COMPARE_57
    output = _COMPARE_357
    precision = 0.002

[compare]
    input = _INPUT_PITCH
    compare = _FIFTH_PITCH
    ifequal = 2
    else = _COMPARE_7
    output = _COMPARE_57
    precision = 0.002

[compare]
    input = _INPUT_PITCH
    compare = _SEVENTH_PITCH
    ifequal = 1
    else = -1
    output = _COMPARE_7
    precision = 0.002

# -------------------------------------------------
# Alternative Harmony
# -------------------------------------------------

[switch]
    input1 = _ALTERNATIVE_FIRST_DELTA_DIM
    input2 = _ALTERNATIVE_FIRST_DELTA_RANDOM
    input3 = _ALTERNATIVE_FIRST_DELTA_DIMMAJ7
    input4 = _ALTERNATIVE_FIRST_DELTA_RANDOM
    offset = _HARMONIZER
    output1 = _ALTERNATIVE_FIRST_DELTA

[switch]
    input1 = _ALTERNATIVE_SECOND_DELTA_DIM
    input2 = _ALTERNATIVE_SECOND_DELTA_RANDOM
    input3 = _ALTERNATIVE_SECOND_DELTA_DIMMAJ7
    input4 = _ALTERNATIVE_SECOND_DELTA_RANDOM
    offset = _HARMONIZER
    output1 = _ALTERNATIVE_SECOND_DELTA

[switch]
    input1 = _ALTERNATIVE_THIRD_DELTA_DIM
    input2 = _ALTERNATIVE_THIRD_DELTA_RANDOM
    input3 = _ALTERNATIVE_THIRD_DELTA_DIMMAJ7
    input4 = _ALTERNATIVE_THIRD_DELTA_RANDOM
    offset = _HARMONIZER
    output1 = _ALTERNATIVE_THIRD_DELTA

# -------------------------------------------------
# Alternative Harmony: Random
# -------------------------------------------------

[multicompare]
    input = _HARMONIZER
    compare1 = 1
    compare2 = 3
    ifequal1 = _NOTECHANGE
    ifequal2 = B1.4
    else = 1
    output = _RANDOMCLOCK

[random]
    clock = _RANDOMCLOCK
    minimum = 2
    maximum = 5
    steps = 4
    output = _RAND_3RD

[compare]
    input = _RAND_3RD
    compare = 5
    ifequal = 7
    else = 6
    output = _RAND_MIN_5TH

[compare]
    input = _RAND_3RD
    compare = 5
    ifequal = 2
    else = 3
    output = _RAND_STEPS_5TH

[random]
    clock = _RANDOMCLOCK
    minimum = _RAND_MIN_5TH
    maximum = 8
    steps = _RAND_STEPS_5TH
    output = _RAND_5TH

[compare]
    input = _RAND_5TH
    compare = 8
    ifequal = 10
    else = 9
    output = _RAND_MIN_7TH

[compare]
    input = _RAND_5TH
    compare = 8
    ifequal = 2
    else = 3
    output = _RAND_STEPS_7TH

[random]
    clock = _RANDOMCLOCK
    minimum = _RAND_MIN_7TH
    maximum = 11
    steps = _RAND_STEPS_7TH
    output = _RAND_7TH

[math]
    input1 = 0
    input2 = _RAND_3RD
    difference = _RAND_THIRD_MINUS_ROOT

[math]
    input1 = _RAND_3RD
    input2 = _RAND_5TH
    difference = _RAND_FIFTH_MINUS_THIRD

[math]
    input1 = _RAND_5TH
    input2 = _RAND_7TH
    difference = _RAND_SEVENTH_MINUS_FIFTH

[math]
    input1 = _RAND_7TH
    input2 = 12
    difference = _RAND_ROOT_MINUS_SEVENTH

# This switch determines *in which order* to subtract "deltas" (in semitones) in order to derive the correct chord inversion from the melody note.  I.e. if the melody note is the root, then to get the first harmony note you'd subtract the "root minus seventh" delta, but if the melody note is the third then to get the first harmony note you'd subtract "third minus root".
[switch]
    input1 = _RAND_ROOT_MINUS_SEVENTH
    input2 = _RAND_SEVENTH_MINUS_FIFTH
    input3 = _RAND_FIFTH_MINUS_THIRD
    input4 = _RAND_THIRD_MINUS_ROOT
    offset = _RAND_OFFSET
    output1 = _ALTERNATIVE_FIRST_DELTA_RANDOM
    output2 = _ALTERNATIVE_SECOND_DELTA_RANDOM
    output3 = _ALTERNATIVE_THIRD_DELTA_RANDOM

[random]
    clock = _RANDOMCLOCK
    minimum = 0
    maximum = 3
    steps = 4
    output = _RAND_OFFSET

# -------------------------------------------------
# Alternative Harmony: Diminished
# -------------------------------------------------

[copy]
    input = -3
    output = _ALTERNATIVE_FIRST_DELTA_DIM

[copy]
    input = -3
    output = _ALTERNATIVE_SECOND_DELTA_DIM

[copy]
    input = -3
    output = _ALTERNATIVE_THIRD_DELTA_DIM

# -------------------------------------------------
# Alternative Harmony: Diminished Maj7
# -------------------------------------------------

[copy]
    input = -5
    output = _ALTERNATIVE_FIRST_DELTA_DIMMAJ7

[copy]
    input = -3
    output = _ALTERNATIVE_SECOND_DELTA_DIMMAJ7

[copy]
    input = -3
    output = _ALTERNATIVE_THIRD_DELTA_DIMMAJ7

# -------------------------------------------------
# Output Harmony
# -------------------------------------------------

# This switch determines *in which order* to subtract "deltas" (in semitones) in order to derive the correct chord inversion from the melody note.  I.e. if the melody note is the root, then to get the first harmony note you'd subtract the "root minus seventh" delta, but if the melody note is the third then to get the first harmony note you'd subtract "third minus root".
[switch]
    input1 = _ROOT_MINUS_SEVENTH
    input2 = _SEVENTH_MINUS_FIFTH
    input3 = _FIFTH_MINUS_THIRD
    input4 = _THIRD_MINUS_ROOT
    offset = _MATCHING_INDEX
    output1 = _CHORDTONE_FIRST_DELTA
    output2 = _CHORDTONE_SECOND_DELTA
    output3 = _CHORDTONE_THIRD_DELTA

# If the input note matched any chord note, use chordtone harmony, otherwise use alternative harmony.
[compare]
    input = _MATCHING_INDEX
    compare = -1
    ifequal = _ALTERNATIVE_FIRST_DELTA
    else = _CHORDTONE_FIRST_DELTA
    output = _FIRST_DELTA

# If the input note matched any chord note, use chordtone harmony, otherwise use alternative harmony.
[compare]
    input = _MATCHING_INDEX
    compare = -1
    ifequal = _ALTERNATIVE_SECOND_DELTA
    else = _CHORDTONE_SECOND_DELTA
    output = _SECOND_DELTA

# If the input note matched any chord note, use chordtone harmony, otherwise use alternative harmony.
[compare]
    input = _MATCHING_INDEX
    compare = -1
    ifequal = _ALTERNATIVE_THIRD_DELTA
    else = _CHORDTONE_THIRD_DELTA
    output = _THIRD_DELTA

[copy]
    input = _QUANTIZED_INPUT * 120
    output = _OUTPITCH1

[copy]
    input = _OUTPITCH1 + _FIRST_DELTA
    output = _OUTPITCH2

[copy]
    input = _OUTPITCH2 + _SECOND_DELTA
    output = _OUTPITCH3

[copy]
    input = _OUTPITCH3 + _THIRD_DELTA
    output = _OUTPITCH4

[copy]
    input = _OUTPITCH1 / 120
    output = O1

[copy]
    input = _OUTPITCH2 / 120
    output = O2

[copy]
    input = _OUTPITCH3 / 120
    output = O3

[copy]
    input = _OUTPITCH4 / 120
    output = O4

# -------------------------------------------------
# TODO
# TODO:
# - Implement other alternative harmonies
# - Implement drop 2 and drop 2/4 voicings
# - Show stage with LEDs (don't think the circuit supports this)
# - Instead of "adv" and "reset", consider just going direct to each stage with a button press (note, the circuit doesn't seem to support this)
# -------------------------------------------------
